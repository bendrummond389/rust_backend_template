File: ./tests/mod.rs
mod users;

File: ./tests/users/create_user_test.rs
use actix_web::{test, App};
use code2media::routes::user::configure;
use env_logger;
use serde_json::json;
use std::env;

#[actix_rt::test]
async fn test_user_creation() {
    let _ = env_logger::try_init();
    env::set_var("RUNNING_TEST", "1");

    let mut app = test::init_service(App::new().configure(configure)).await;

    let user_data = json!({
        "name": "Test User",
        "email": "test@example.com"
    });

    let req = test::TestRequest::post()
        .uri("/users")
        .set_json(&user_data)
        .to_request();

    let resp = test::call_service(&mut app, req).await;

    assert!(resp.status().is_success(), "Failed to create user");
}

File: ./tests/users/mod.rs
mod create_user_test;
mod get_user_test;

File: ./tests/users/get_user_test.rs
use actix_web::{test, App};
use code2media::routes::user::configure;
use serde_json::json;
use serde_json::Value;
use std::env;

#[actix_rt::test]
async fn test_user_fetching() {
    let _ = env_logger::try_init();
    env::set_var("RUNNING_TEST", "1");

    let mut app = test::init_service(App::new().configure(configure)).await;

    let user_data = json!({
      "name": "Test User",
      "email": "test@example.com"
    });

    let create_req = test::TestRequest::post()
        .uri("/users")
        .set_json(&user_data)
        .to_request();
    let create_resp = test::call_service(&mut app, create_req).await;
    assert!(create_resp.status().is_success(), "Failed to create user");

    let created_user: Value = test::read_body_json(create_resp).await;
    let user_id = created_user["id"].as_i64().expect("Failed to get user ID");

    // Fetch the created user
    let fetch_req = test::TestRequest::get()
        .uri(&format!("/users/{}", user_id))
        .to_request();
    let fetch_resp = test::call_service(&mut app, fetch_req).await;
    assert!(fetch_resp.status().is_success(), "Failed to fetch user");

    // Verify the fetched user
    let fetched_user: Value = test::read_body_json(fetch_resp).await;
    assert_eq!(
        fetched_user["id"].as_i64(),
        Some(user_id),
        "Fetched user ID does not match"
    );
}

File: ./src/bin/seed_database.rs
extern crate code2media;

use code2media::utils::seed::seed_database;

fn main() {
    let database_url = "postgres://test_user:test_password@localhost:5433/postgres_test";
    seed_database(database_url);
}

File: ./src/lib.rs

pub mod controllers;
pub mod db;
pub mod models;
pub mod routes;
pub mod schema;
pub mod utils;

// If you want to re-export items for direct use in main.rs
pub use db::*;
pub use models::*;
pub use crate::routes::user::configure;
File: ./src/utils/mod.rs
pub mod seed;
File: ./src/utils/seed.rs
use crate::schema::users;
use crate::user::NewUser;
use diesel::pg::PgConnection;
use diesel::prelude::*;

pub fn seed_database(database_url: &str) {
    let mut connection =
        PgConnection::establish(database_url).expect("failed to connect to database");

    let users = vec![
        NewUser {
            name: "John Doe",
            email: "john@example.com",
        },
        NewUser {
            name: "Jane Doe",
            email: "jane@example.com",
        },
    ];

    for user in users {
        diesel::insert_into(users::table)
            .values(&user)
            .execute(&mut connection)
            .expect("Error seeding user");
    }
}

File: ./src/models/user.rs
use crate::schema::users;
use diesel::Insertable;
use diesel::Queryable;
use serde::Serialize;

#[derive(Insertable)]
#[diesel(table_name = users)]
pub struct NewUser<'a> {
    pub name: &'a str,
    pub email: &'a str,
}

#[derive(Queryable, Serialize)]
pub struct User {
    pub id: i32,
    pub name: String,
    pub email: String,
}

File: ./src/models/mod.rs
pub mod user;

pub use self::user::User;
File: ./src/schema.rs
// @generated automatically by Diesel CLI.

diesel::table! {
    users (id) {
        id -> Int4,
        name -> Varchar,
        email -> Varchar,
    }
}

File: ./src/db/mod.rs
pub mod connection;

pub use self::connection::establish_connection;

File: ./src/db/connection.rs
use diesel::pg::PgConnection;
use diesel::prelude::*;
use dotenv::dotenv;
use std::env;

pub fn establish_connection() -> PgConnection {
    dotenv().ok();

    // Check if we are in a test environment
    let database_url = match env::var("RUNNING_TEST") {
        Ok(_) => env::var("TEST_DATABASE_URL").expect("TEST_DATABASE_URL must be set"),
        Err(_) => env::var("DATABASE_URL").expect("DATABASE_URL must be set"),
    };

    PgConnection::establish(&database_url)
        .unwrap_or_else(|_| panic!("Error connecting to {}", database_url))
}

File: ./src/main.rs
use actix_web::{web, App, HttpServer};
use std::io;


use code2media::routes::user::configure;

#[actix_web::main]
async fn main() -> io::Result<()> {
    HttpServer::new(move || {
        App::new()
            .service(web::scope("/api").configure(configure))
    })
    .bind("127.0.0.1:8080")?
    .run()
    .await
}
File: ./src/controllers/user_controller.rs
use crate::db::connection::establish_connection;
use crate::models::user::{NewUser, User};
use crate::schema::users;
use diesel::prelude::*;

pub fn create_user(new_user: NewUser) -> Result<User, diesel::result::Error> {
    let mut conn = establish_connection();

    diesel::insert_into(users::table)
        .values(&new_user)
        .get_result(&mut conn)
}

pub fn get_user(user_id: i32) -> Result<User, diesel::result::Error> {
    let mut conn = establish_connection();

    users::table.find(user_id).first(&mut conn)
}

File: ./src/controllers/mod.rs
pub mod user_controller;
File: ./src/routes/user.rs
use crate::controllers::user_controller;
use crate::models::user::NewUser;
use actix_web::web::Path;
use actix_web::{web, HttpResponse, Responder};
use serde::Deserialize;

// Define a data structure for incoming user data
#[derive(Deserialize)]
pub struct UserData {
    name: String,
    email: String,
}

pub async fn create_user_endpoint(user_data: web::Json<UserData>) -> impl Responder {
    // Convert UserData to NewUser
    let new_user = NewUser {
        name: &user_data.name,
        email: &user_data.email,
    };

    // Call the controller function to create a user
    match user_controller::create_user(new_user) {
        Ok(user) => HttpResponse::Ok().json(user),
        Err(_) => HttpResponse::InternalServerError().finish(),
    }
}

pub async fn get_user_endpoint(user_id: Path<i32>) -> impl Responder {
    match user_controller::get_user(user_id.into_inner()) {
        Ok(user) => HttpResponse::Ok().json(user),
        Err(_) => HttpResponse::NotFound().finish(),
    }
}

pub fn configure(cfg: &mut web::ServiceConfig) {
    cfg.service(web::resource("/users").route(web::post().to(create_user_endpoint)))
        .service(web::resource("/users/{id}").route(web::get().to(get_user_endpoint)));
}

File: ./src/routes/mod.rs
pub mod user;


