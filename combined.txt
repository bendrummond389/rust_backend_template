File: ./tests/utils/mod.rs
pub mod containers;
mod seed;
mod setup;

pub use self::seed::seed_database;
pub use self::setup::establish_connection_and_run_migrations;

File: ./tests/utils/containers/docker_setup.rs
pub fn generate_database_url(port: u16) -> String {
    format!(
        "postgres://test_user:test_password@localhost:{}/postgres",
        port
    )
}

File: ./tests/utils/containers/pg_image.rs
use std::collections::HashMap;
use testcontainers::core::{Image, WaitFor};

const NAME: &str = "postgres";
const TAG: &str = "16-alpine";

#[derive(Debug)]
pub struct PostgresImage {
    env_vars: HashMap<String, String>,
}

impl Default for PostgresImage {
    fn default() -> Self {
        let mut env_vars = HashMap::new();
        env_vars.insert("POSTGRES_USER".to_owned(), "test_user".to_owned());
        env_vars.insert("POSTGRES_PASSWORD".to_owned(), "test_password".to_owned());
        env_vars.insert("POSTGRES_DB".to_owned(), "postgres".to_owned());
        env_vars.insert("POSTGRES_HOST_AUTH_METHOD".into(), "trust".into());

        Self { env_vars }
    }
}

impl Image for PostgresImage {
    type Args = ();

    fn name(&self) -> String {
        NAME.to_owned()
    }

    fn tag(&self) -> String {
        TAG.to_owned()
    }

    fn ready_conditions(&self) -> Vec<WaitFor> {
        vec![
            WaitFor::StdOutMessage {
                message: "database system is ready to accept connections".to_string(),
            },
            WaitFor::seconds(1),
        ]
    }

    fn env_vars(&self) -> Box<dyn Iterator<Item = (&String, &String)> + '_> {
        Box::new(self.env_vars.iter())
    }
}

File: ./tests/utils/containers/mod.rs
pub mod pg_image;
pub mod docker_setup;
File: ./tests/utils/seed.rs
use code2media::schema::users;
use code2media::user::NewUser;
use diesel::pg::PgConnection;
use diesel::prelude::*;

pub fn seed_database(database_url: &str) {
    let mut connection =
        PgConnection::establish(database_url).expect("failed to connect to database");

    let users = vec![
        NewUser {
            name: "John Doe",
            email: "john@example.com",
        },
        NewUser {
            name: "Jane Doe",
            email: "jane@example.com",
        },
    ];

    for user in users {
        diesel::insert_into(users::table)
            .values(&user)
            .execute(&mut connection)
            .expect("Error seeding user");
    }
}

File: ./tests/utils/setup.rs
use diesel::{Connection, PgConnection};
use diesel_migrations::{embed_migrations, EmbeddedMigrations, MigrationHarness};
use log::{error, info};

type DB = diesel::pg::Pg;

const MIGRATIONS: EmbeddedMigrations = embed_migrations!();

pub fn establish_connection_and_run_migrations(database_url: &str) -> PgConnection {
    let mut connection = PgConnection::establish(database_url)
        .unwrap_or_else(|_| panic!("Error connecting to {}", database_url));
    run_database_migrations(&mut connection);
    connection
}

fn run_database_migrations(conn: &mut impl MigrationHarness<DB>) {
    match conn.run_pending_migrations(MIGRATIONS) {
        Ok(_) => info!("Migrations run successfully"),
        Err(e) => error!("Error running migrations: {}", e),
    }
}

File: ./tests/mod.rs
mod users;
mod utils;
File: ./tests/users/create_user_test.rs
use crate::utils::containers::docker_setup::generate_database_url;
use crate::utils::containers::pg_image::PostgresImage;
use crate::utils::establish_connection_and_run_migrations;
use crate::utils::seed_database;
use actix_web::{test, App};
use code2media::routes::user::configure;
use serde_json::json;
use std::env;
use std::thread;
use std::time;
use testcontainers::clients;

#[actix_rt::test]
async fn test_user_creation() {
    let docker = clients::Cli::default();
    let image = PostgresImage::default();
    let container = docker.run(image);
    let port = container.get_host_port_ipv4(5432);

    let database_url = generate_database_url(port);
    env::set_var("DATABASE_URL", &database_url);

    establish_connection_and_run_migrations(&database_url);

    seed_database(&database_url);

    thread::sleep(time::Duration::from_secs(60));

    let mut app = test::init_service(App::new().configure(configure)).await;

    let user_data = json!({
        "name": "Test User",
        "email": "test@example.com"
    });

    // Create a request for user creation
    let req = test::TestRequest::post()
        .uri("/users")
        .set_json(&user_data)
        .to_request();

    // Call service with the request
    let resp = test::call_service(&mut app, req).await;

    // Assert the response
    assert!(resp.status().is_success(), "Failed to create user");
}

File: ./tests/users/mod.rs
mod create_user_test;
// mod get_user_test;

File: ./tests/users/get_user_test.rs
use crate::utils::containers::docker_setup::generate_database_url;
use crate::utils::containers::pg_image::PostgresImage;
use crate::utils::establish_connection_and_run_migrations;
use crate::utils::seed_database;
use actix_web::{test, App};
use code2media::routes::user::configure;
use serde_json::Value;
use std::env;

use testcontainers::clients;

#[actix_rt::test]
async fn test_user_fetching() {
    let docker = clients::Cli::default();
    let image = PostgresImage::default();
    let container = docker.run(image);
    let port = container.get_host_port_ipv4(5432);
    let user_id = 1;

    let database_url = generate_database_url(port);
    env::set_var("DATABASE_URL", &database_url);

    establish_connection_and_run_migrations(&database_url);

    seed_database(&database_url);

    let mut app = test::init_service(App::new().configure(configure)).await;

    // Fetch the created user
    let fetch_req = test::TestRequest::get()
        .uri(&format!("/users/{}", user_id))
        .to_request();
    let fetch_resp = test::call_service(&mut app, fetch_req).await;
    assert!(fetch_resp.status().is_success(), "Failed to fetch user");

    // Verify the fetched user
    let fetched_user: Value = test::read_body_json(fetch_resp).await;
    assert_eq!(
        fetched_user["id"].as_i64(),
        Some(user_id),
        "Fetched user ID does not match"
    );
}

File: ./src/lib.rs
pub mod controllers;
pub mod db;
pub mod models;
pub mod routes;
pub mod schema;

pub use crate::routes::user::configure;
pub use db::*;
pub use models::*;

File: ./src/models/user.rs
use crate::schema::users;
use diesel::Insertable;
use diesel::Queryable;
use serde::Serialize;

#[derive(Insertable)]
#[diesel(table_name = users)]
pub struct NewUser<'a> {
    pub name: &'a str,
    pub email: &'a str,
}

#[derive(Queryable, Serialize)]
pub struct User {
    pub id: i32,
    pub name: String,
    pub email: String,
}

File: ./src/models/mod.rs
pub mod user;

pub use self::user::User;
File: ./src/schema.rs
// @generated automatically by Diesel CLI.

diesel::table! {
    users (id) {
        id -> Int4,
        name -> Varchar,
        email -> Varchar,
    }
}

File: ./src/db/mod.rs
pub mod connection;

pub use self::connection::establish_connection;

File: ./src/db/connection.rs
use diesel::pg::PgConnection;
use diesel::prelude::*;
use dotenv::dotenv;
use std::env;

pub fn establish_connection() -> PgConnection {
    dotenv().ok();

    // Check if we are in a test environment
    let database_url = env::var("DATABASE_URL").expect("DATABASE_URL must be set");

    PgConnection::establish(&database_url)
        .unwrap_or_else(|_| panic!("Error connecting to {}", database_url))
}

File: ./src/main.rs
use actix_web::{web, App, HttpServer};
use std::io;


use code2media::routes::user::configure;

#[actix_web::main]
async fn main() -> io::Result<()> {
    HttpServer::new(move || {
        App::new()
            .service(web::scope("/api").configure(configure))
    })
    .bind("127.0.0.1:8080")?
    .run()
    .await
}
File: ./src/controllers/user_controller.rs
use crate::db::connection::establish_connection;
use crate::models::user::{NewUser, User};
use crate::schema::users;
use diesel::prelude::*;

pub fn create_user(new_user: NewUser) -> Result<User, diesel::result::Error> {
    let mut conn = establish_connection();

    diesel::insert_into(users::table)
        .values(&new_user)
        .get_result(&mut conn)
}

pub fn get_user(user_id: i32) -> Result<User, diesel::result::Error> {
    let mut conn = establish_connection();

    users::table.find(user_id).first(&mut conn)
}



File: ./src/controllers/mod.rs
pub mod user_controller;
File: ./src/routes/user.rs
use crate::controllers::user_controller;
use crate::models::user::NewUser;
use actix_web::web::Path;
use actix_web::{web, HttpResponse, Responder};
use serde::Deserialize;

// Define a data structure for incoming user data
#[derive(Deserialize)]
pub struct UserData {
    name: String,
    email: String,
}

pub async fn create_user_endpoint(user_data: web::Json<UserData>) -> impl Responder {
    // Convert UserData to NewUser
    let new_user = NewUser {
        name: &user_data.name,
        email: &user_data.email,
    };

    // Call the controller function to create a user
    match user_controller::create_user(new_user) {
        Ok(user) => HttpResponse::Ok().json(user),
        Err(_) => HttpResponse::InternalServerError().finish(),
    }
}

pub async fn get_user_endpoint(user_id: Path<i32>) -> impl Responder {
    match user_controller::get_user(user_id.into_inner()) {
        Ok(user) => HttpResponse::Ok().json(user),
        Err(_) => HttpResponse::NotFound().finish(),
    }
}

pub fn configure(cfg: &mut web::ServiceConfig) {
    cfg.service(web::resource("/users").route(web::post().to(create_user_endpoint)))
        .service(web::resource("/users/{id}").route(web::get().to(get_user_endpoint)));
}

File: ./src/routes/mod.rs
pub mod user;


