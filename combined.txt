File: ./tests/setup/mod.rs
pub mod setup;

pub use setup::{prepare_test_db, revert_test_db};
File: ./tests/setup/setup.rs
use diesel::connection::Connection;
use diesel::pg::PgConnection;
use diesel_migrations::{embed_migrations, EmbeddedMigrations, MigrationHarness};
use dotenv::dotenv;
use log::{error, info};
use std::env;

const MIGRATIONS: EmbeddedMigrations = embed_migrations!();

type DB = diesel::pg::Pg;

fn establish_connection(database_url: &str) -> Result<PgConnection, String> {
    PgConnection::establish(&database_url)
        .map_err(|e| format!("Error connecting to database: {}", e))
}

fn run_database_migrations(conn: &mut impl MigrationHarness<DB>) {
    match conn.run_pending_migrations(MIGRATIONS) {
        Ok(_) => info!("Migrations run successfully"),
        Err(e) => error!("Error reverting migrations: {}", e),
    }
}

fn revert_database_migrations(conn: &mut impl MigrationHarness<DB>) {
    match conn.revert_all_migrations(MIGRATIONS) {
        Ok(_) => info!("Migrations reverted successfully"),
        Err(e) => error!("Error reverting migrations: {}", e),
    }
}

fn get_database_url() -> String {
    dotenv().ok();
    let database_url = env::var("TEST_DATABASE_URL").expect("TEST_DATABASE_URL must be set");
    database_url
}

pub fn prepare_test_db() -> Result<(), String> {
    let database_url = get_database_url();
    let mut connection = establish_connection(&database_url)?;
    run_database_migrations(&mut connection);
    Ok(())
}

pub fn revert_test_db() -> Result<(), String> {
    let database_url = get_database_url();
    let mut connection = establish_connection(&database_url)?;
    revert_database_migrations(&mut connection);
    Ok(())
}

File: ./tests/mod.rs
mod setup; 
mod users;
File: ./tests/users/create_user_test.rs
use crate::setup::{prepare_test_db, revert_test_db};
use env_logger;

#[test]
fn test_user_creation() {
    let _ = env_logger::try_init();

    prepare_test_db().expect("Test DB setup failed");

    // test logic here

    revert_test_db().expect("Test DB revert failed");
}
File: ./tests/users/mod.rs
mod create_user_test;
File: ./src/lib.rs

pub mod controllers;
pub mod db;
pub mod models;
pub mod routes;
pub mod schema;

// If you want to re-export items for direct use in main.rs
pub use db::*;
pub use models::*;
pub use crate::routes::user::configure;
File: ./src/models/user.rs
use crate::schema::users;
use diesel::Insertable;
use diesel::Queryable;
use serde::Serialize;

#[derive(Insertable)]
#[diesel(table_name = users)]
pub struct NewUser<'a> {
    pub name: &'a str,
    pub email: &'a str,
    // other fields
}

#[derive(Queryable, Serialize)]
pub struct User {
    pub id: i32,
    pub name: String,
    pub email: String,
    // Include other fields that your users table contains
}

File: ./src/models/mod.rs
pub mod user;

pub use self::user::User;
File: ./src/schema.rs
// @generated automatically by Diesel CLI.

diesel::table! {
    users (id) {
        id -> Int4,
        name -> Varchar,
        email -> Varchar,
    }
}

File: ./src/db/mod.rs
pub mod connection;

pub use self::connection::establish_connection;

File: ./src/db/connection.rs
use diesel::prelude::*;
use dotenv::dotenv;
use std::env;

pub fn establish_connection() -> PgConnection {
    dotenv().ok();

    let database_url = if cfg!(test) {
        env::var("TEST_DATABASE_URL").expect("TEST_DATABASE_URL must be set")
    } else {
        env::var("DATABASE_URL").expect("DATABASE_URL must be set")
    };
    PgConnection::establish(&database_url).expect(&format!("Error connecting to {}", database_url))
}

File: ./src/main.rs
use actix_web::{web, App, HttpServer};
use std::io;


use code2media::routes::user::configure;

#[actix_web::main]
async fn main() -> io::Result<()> {
    HttpServer::new(move || {
        App::new()
            .service(web::scope("/api").configure(configure))
    })
    .bind("127.0.0.1:8080")?
    .run()
    .await
}
File: ./src/controllers/user_controller.rs
use crate::db::connection::establish_connection;
use crate::models::user::{User, NewUser};
use diesel::prelude::*;

pub fn create_user(new_user: NewUser) -> Result<User, diesel::result::Error> {
    use crate::schema::users;

    let mut conn = establish_connection(); 
    let result = diesel::insert_into(users::table)
        .values(&new_user)
        .get_result(&mut conn); 

    result
}

File: ./src/controllers/mod.rs
pub mod user_controller;
File: ./src/routes/user.rs
use crate::controllers::user_controller;
use crate::models::user::NewUser;
use actix_web::{web, HttpResponse, Responder};
use serde::Deserialize;

// Define a data structure for incoming user data
#[derive(Deserialize)]
pub struct UserData {
    name: String,
    email: String,
    // Add other fields as necessary
}

pub async fn create_user_endpoint(user_data: web::Json<UserData>) -> impl Responder {
    // Convert UserData to NewUser
    let new_user = NewUser {
        name: &user_data.name,
        email: &user_data.email,
        // Map other fields as necessary
    };

    // Call the controller function to create a user
    match user_controller::create_user(new_user) {
        Ok(user) => HttpResponse::Ok().json(user), // Send a success response
        Err(_) => HttpResponse::InternalServerError().finish(), // Send an error response
    }
}


pub fn configure(cfg: &mut web::ServiceConfig) {
  cfg.service(
      web::resource("/users")
          .route(web::post().to(create_user_endpoint)),
  );
  // Add other user-related routes here if necessary
}
File: ./src/routes/mod.rs
pub mod user;


