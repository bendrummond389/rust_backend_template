File: ./src/lib.rs

pub mod controllers;
pub mod db;
pub mod models;
pub mod routes;
pub mod schema;

// If you want to re-export items for direct use in main.rs
pub use db::*;
pub use models::*;
pub use crate::routes::user::configure;
File: ./src/models/user.rs
use crate::schema::users;
use diesel::Insertable;
use diesel::Queryable;
use serde::Serialize;

#[derive(Insertable)]
#[diesel(table_name = users)]
pub struct NewUser<'a> {
    pub name: &'a str,
    pub email: &'a str,
    // other fields
}

#[derive(Queryable, Serialize)]
pub struct User {
    pub id: i32,
    pub name: String,
    pub email: String,
    // Include other fields that your users table contains
}

File: ./src/models/mod.rs
pub mod user;

pub use self::user::User;
File: ./src/schema.rs
// @generated automatically by Diesel CLI.

diesel::table! {
    users (id) {
        id -> Int4,
        name -> Varchar,
        email -> Varchar,
    }
}

File: ./src/db/mod.rs
pub mod connection;

pub use self::connection::establish_connection;

File: ./src/db/connection.rs
use diesel::pg::PgConnection;
use diesel::prelude::*;
use dotenv::dotenv;
use std::env;

pub fn establish_connection() -> PgConnection {
    dotenv().ok();

    let database_url = env::var("DATABASE_URL")
        .expect("DATABASE_URL must be set");
    PgConnection::establish(&database_url)
        .expect(&format!("Error connecting to {}", database_url))
}
File: ./src/main.rs
use actix_web::{web, App, HttpServer};
use std::io;


use code2media::routes::user::configure;

#[actix_web::main]
async fn main() -> io::Result<()> {
    HttpServer::new(move || {
        App::new()
            .service(web::scope("/api").configure(configure))
    })
    .bind("127.0.0.1:8080")?
    .run()
    .await
}
File: ./src/controllers/user_controller.rs
use crate::db::connection::establish_connection;
use crate::models::user::{User, NewUser};
use diesel::prelude::*;

pub fn create_user(new_user: NewUser) -> Result<User, diesel::result::Error> {
    use crate::schema::users;

    let mut conn = establish_connection(); 
    let result = diesel::insert_into(users::table)
        .values(&new_user)
        .get_result(&mut conn); 

    result
}

File: ./src/controllers/mod.rs
pub mod user_controller;
File: ./src/routes/user.rs
use crate::controllers::user_controller;
use crate::models::user::NewUser;
use actix_web::{web, HttpResponse, Responder};
use serde::Deserialize;

// Define a data structure for incoming user data
#[derive(Deserialize)]
pub struct UserData {
    name: String,
    email: String,
    // Add other fields as necessary
}

pub async fn create_user_endpoint(user_data: web::Json<UserData>) -> impl Responder {
    // Convert UserData to NewUser
    let new_user = NewUser {
        name: &user_data.name,
        email: &user_data.email,
        // Map other fields as necessary
    };

    // Call the controller function to create a user
    match user_controller::create_user(new_user) {
        Ok(user) => HttpResponse::Ok().json(user), // Send a success response
        Err(_) => HttpResponse::InternalServerError().finish(), // Send an error response
    }
}


pub fn configure(cfg: &mut web::ServiceConfig) {
  cfg.service(
      web::resource("/users")
          .route(web::post().to(create_user_endpoint)),
  );
  // Add other user-related routes here if necessary
}
File: ./src/routes/mod.rs
pub mod user;


